// Code generated by goa v3.7.2, DO NOT EDIT.
//
// Zebrahook HTTP server types
//
// Command:
// $ goa gen zebrahook/design

package server

import (
	"unicode/utf8"
	zebrahook "zebrahook/gen/zebrahook"

	goa "goa.design/goa/v3/pkg"
)

// SubmitNewEventsRequestBody is the type of the "Zebrahook" service
// "submitNewEvents" endpoint HTTP request body.
type SubmitNewEventsRequestBody struct {
	Events []*EventRequestRequestBody `form:"events,omitempty" json:"events,omitempty" xml:"events,omitempty"`
}

// RegisterRequestBody is the type of the "Zebrahook" service "register"
// endpoint HTTP request body.
type RegisterRequestBody struct {
	// URL of the webhook that will be called on each `enabled_events`
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events,omitempty" json:"enabled_events,omitempty" xml:"enabled_events,omitempty"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// UpdateRequestBody is the type of the "Zebrahook" service "update" endpoint
// HTTP request body.
type UpdateRequestBody struct {
	// URL of the webhook that will be called on each `enabled_events`
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// If true this webhook endpoint won't receive any events, set to false to
	// re-enable it
	Disabled *bool `form:"disabled,omitempty" json:"disabled,omitempty" xml:"disabled,omitempty"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events,omitempty" json:"enabled_events,omitempty" xml:"enabled_events,omitempty"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// SubmitNewEventsResponseBody is the type of the "Zebrahook" service
// "submitNewEvents" endpoint HTTP response body.
type SubmitNewEventsResponseBody struct {
	Success *bool `form:"success,omitempty" json:"success,omitempty" xml:"success,omitempty"`
}

// RegisterResponseBody is the type of the "Zebrahook" service "register"
// endpoint HTTP response body.
type RegisterResponseBody struct {
	// identifier of the webhook
	ID string `form:"id" json:"id" xml:"id"`
	// secret to be used by the webhook to verify the events
	Secret string `form:"secret" json:"secret" xml:"secret"`
}

// UpdateResponseBody is the type of the "Zebrahook" service "update" endpoint
// HTTP response body.
type UpdateResponseBody struct {
	Success *bool `form:"success,omitempty" json:"success,omitempty" xml:"success,omitempty"`
}

// ListWebhookEndpointResponseBody is the type of the "Zebrahook" service
// "listWebhookEndpoint" endpoint HTTP response body.
type ListWebhookEndpointResponseBody struct {
	Result []*WebhookEndpointWithoutSecretResponseBody `form:"result" json:"result" xml:"result"`
}

// GetWebhookEndpointByIDResponseBody is the type of the "Zebrahook" service
// "getWebhookEndpointById" endpoint HTTP response body.
type GetWebhookEndpointByIDResponseBody struct {
	// when this item was created (unix timestamp seconds)
	CreatedAt int64 `form:"createdAt" json:"createdAt" xml:"createdAt"`
	// when this item was last updated (unix timestamp seconds)
	UpdatedAt int64 `form:"updatedAt" json:"updatedAt" xml:"updatedAt"`
	// status of current endpoint, enabled means that the webhook endpoint is
	// eligible for receiving webhook events
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// URL of the webhook that will be called on each `enabled_events`
	URL string `form:"url" json:"url" xml:"url"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events" json:"enabled_events" xml:"enabled_events"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
	// identifier of the webhook
	ID string `form:"id" json:"id" xml:"id"`
	// secret to be used by the webhook to verify the events
	Secret string `form:"secret" json:"secret" xml:"secret"`
}

// WebhookEndpointWithoutSecretResponseBody is used to define fields on
// response body types.
type WebhookEndpointWithoutSecretResponseBody struct {
	// when this item was created (unix timestamp seconds)
	CreatedAt int64 `form:"createdAt" json:"createdAt" xml:"createdAt"`
	// when this item was last updated (unix timestamp seconds)
	UpdatedAt int64 `form:"updatedAt" json:"updatedAt" xml:"updatedAt"`
	// status of current endpoint, enabled means that the webhook endpoint is
	// eligible for receiving webhook events
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// URL of the webhook that will be called on each `enabled_events`
	URL string `form:"url" json:"url" xml:"url"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events" json:"enabled_events" xml:"enabled_events"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
	// identifier of the webhook
	ID string `form:"id" json:"id" xml:"id"`
}

// EventRequestRequestBody is used to define fields on request body types.
type EventRequestRequestBody struct {
	// Event type of the `event_content`
	EventType *string `form:"event_type,omitempty" json:"event_type,omitempty" xml:"event_type,omitempty"`
	// event content that will be dispatched (any json object)
	EventContent map[string]interface{} `form:"event_content,omitempty" json:"event_content,omitempty" xml:"event_content,omitempty"`
	// Optional priority for this event, an higher number will make this event
	// delivered before other ones
	Priority *int `form:"priority,omitempty" json:"priority,omitempty" xml:"priority,omitempty"`
}

// NewSubmitNewEventsResponseBody builds the HTTP response body from the result
// of the "submitNewEvents" endpoint of the "Zebrahook" service.
func NewSubmitNewEventsResponseBody(res *zebrahook.SubmitNewEventsResult) *SubmitNewEventsResponseBody {
	body := &SubmitNewEventsResponseBody{
		Success: res.Success,
	}
	return body
}

// NewRegisterResponseBody builds the HTTP response body from the result of the
// "register" endpoint of the "Zebrahook" service.
func NewRegisterResponseBody(res *zebrahook.WebhookIDAndSecret) *RegisterResponseBody {
	body := &RegisterResponseBody{
		ID:     res.ID,
		Secret: res.Secret,
	}
	return body
}

// NewUpdateResponseBody builds the HTTP response body from the result of the
// "update" endpoint of the "Zebrahook" service.
func NewUpdateResponseBody(res *zebrahook.UpdateResult) *UpdateResponseBody {
	body := &UpdateResponseBody{
		Success: res.Success,
	}
	return body
}

// NewListWebhookEndpointResponseBody builds the HTTP response body from the
// result of the "listWebhookEndpoint" endpoint of the "Zebrahook" service.
func NewListWebhookEndpointResponseBody(res *zebrahook.ListWebhookEndpointResult) *ListWebhookEndpointResponseBody {
	body := &ListWebhookEndpointResponseBody{}
	if res.Result != nil {
		body.Result = make([]*WebhookEndpointWithoutSecretResponseBody, len(res.Result))
		for i, val := range res.Result {
			body.Result[i] = marshalZebrahookWebhookEndpointWithoutSecretToWebhookEndpointWithoutSecretResponseBody(val)
		}
	}
	return body
}

// NewGetWebhookEndpointByIDResponseBody builds the HTTP response body from the
// result of the "getWebhookEndpointById" endpoint of the "Zebrahook" service.
func NewGetWebhookEndpointByIDResponseBody(res *zebrahook.WebhookEndpoint) *GetWebhookEndpointByIDResponseBody {
	body := &GetWebhookEndpointByIDResponseBody{
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
		Status:    res.Status,
		URL:       res.URL,
		ID:        res.ID,
		Secret:    res.Secret,
	}
	if res.EnabledEvents != nil {
		body.EnabledEvents = make([]string, len(res.EnabledEvents))
		for i, val := range res.EnabledEvents {
			body.EnabledEvents[i] = val
		}
	}
	if res.Metadata != nil {
		body.Metadata = make(map[string]string, len(res.Metadata))
		for key, val := range res.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewSubmitNewEventsPayload builds a Zebrahook service submitNewEvents
// endpoint payload.
func NewSubmitNewEventsPayload(body *SubmitNewEventsRequestBody, token string) *zebrahook.SubmitNewEventsPayload {
	v := &zebrahook.SubmitNewEventsPayload{}
	v.Events = make([]*zebrahook.EventRequest, len(body.Events))
	for i, val := range body.Events {
		v.Events[i] = unmarshalEventRequestRequestBodyToZebrahookEventRequest(val)
	}
	v.Token = token

	return v
}

// NewRegisterPayload builds a Zebrahook service register endpoint payload.
func NewRegisterPayload(body *RegisterRequestBody, token string) *zebrahook.RegisterPayload {
	v := &zebrahook.RegisterPayload{
		URL: *body.URL,
	}
	v.EnabledEvents = make([]string, len(body.EnabledEvents))
	for i, val := range body.EnabledEvents {
		v.EnabledEvents[i] = val
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]string, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	v.Token = token

	return v
}

// NewUpdatePayload builds a Zebrahook service update endpoint payload.
func NewUpdatePayload(body *UpdateRequestBody, id string, token string) *zebrahook.UpdatePayload {
	v := &zebrahook.UpdatePayload{
		URL:      body.URL,
		Disabled: body.Disabled,
	}
	if body.EnabledEvents != nil {
		v.EnabledEvents = make([]string, len(body.EnabledEvents))
		for i, val := range body.EnabledEvents {
			v.EnabledEvents[i] = val
		}
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]string, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	v.ID = id
	v.Token = token

	return v
}

// NewListWebhookEndpointPayload builds a Zebrahook service listWebhookEndpoint
// endpoint payload.
func NewListWebhookEndpointPayload(limit int32, offset uint32, createdAtGte *uint64, updatedAtLt *uint64, metadata map[string]string, token string) *zebrahook.ListWebhookEndpointPayload {
	v := &zebrahook.ListWebhookEndpointPayload{}
	v.Limit = limit
	v.Offset = offset
	v.CreatedAtGte = createdAtGte
	v.UpdatedAtLt = updatedAtLt
	v.Metadata = metadata
	v.Token = token

	return v
}

// NewGetWebhookEndpointByIDPayload builds a Zebrahook service
// getWebhookEndpointById endpoint payload.
func NewGetWebhookEndpointByIDPayload(id string, token string) *zebrahook.GetWebhookEndpointByIDPayload {
	v := &zebrahook.GetWebhookEndpointByIDPayload{}
	v.ID = id
	v.Token = token

	return v
}

// ValidateSubmitNewEventsRequestBody runs the validations defined on
// SubmitNewEventsRequestBody
func ValidateSubmitNewEventsRequestBody(body *SubmitNewEventsRequestBody) (err error) {
	if body.Events == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("events", "body"))
	}
	for _, e := range body.Events {
		if e != nil {
			if err2 := ValidateEventRequestRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateRegisterRequestBody runs the validations defined on
// RegisterRequestBody
func ValidateRegisterRequestBody(body *RegisterRequestBody) (err error) {
	if body.URL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("url", "body"))
	}
	if body.EnabledEvents == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("enabled_events", "body"))
	}
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
	}
	if len(body.EnabledEvents) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.enabled_events", body.EnabledEvents, len(body.EnabledEvents), 1, true))
	}
	for k, v := range body.Metadata {
		if utf8.RuneCountInString(k) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata.key", k, utf8.RuneCountInString(k), 1, true))
		}
		if utf8.RuneCountInString(v) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata[key]", v, utf8.RuneCountInString(v), 1, true))
		}
	}
	return
}

// ValidateUpdateRequestBody runs the validations defined on UpdateRequestBody
func ValidateUpdateRequestBody(body *UpdateRequestBody) (err error) {
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
	}
	for k, v := range body.Metadata {
		if utf8.RuneCountInString(k) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata.key", k, utf8.RuneCountInString(k), 1, true))
		}
		if utf8.RuneCountInString(v) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata[key]", v, utf8.RuneCountInString(v), 1, true))
		}
	}
	return
}

// ValidateEventRequestRequestBody runs the validations defined on
// EventRequestRequestBody
func ValidateEventRequestRequestBody(body *EventRequestRequestBody) (err error) {
	if body.EventType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event_type", "body"))
	}
	if body.EventContent == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event_content", "body"))
	}
	return
}
