// Code generated by goa v3.7.2, DO NOT EDIT.
//
// Zebrahook HTTP client types
//
// Command:
// $ goa gen zebrahook/design

package client

import (
	"unicode/utf8"
	zebrahook "zebrahook/gen/zebrahook"

	goa "goa.design/goa/v3/pkg"
)

// SubmitNewEventsRequestBody is the type of the "Zebrahook" service
// "submitNewEvents" endpoint HTTP request body.
type SubmitNewEventsRequestBody struct {
	Events []*EventRequestRequestBody `form:"events" json:"events" xml:"events"`
}

// RegisterRequestBody is the type of the "Zebrahook" service "register"
// endpoint HTTP request body.
type RegisterRequestBody struct {
	// URL of the webhook that will be called on each `enabled_events`
	URL string `form:"url" json:"url" xml:"url"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events" json:"enabled_events" xml:"enabled_events"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// UpdateRequestBody is the type of the "Zebrahook" service "update" endpoint
// HTTP request body.
type UpdateRequestBody struct {
	// URL of the webhook that will be called on each `enabled_events`
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// If true this webhook endpoint won't receive any events, set to false to
	// re-enable it
	Disabled *bool `form:"disabled,omitempty" json:"disabled,omitempty" xml:"disabled,omitempty"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events,omitempty" json:"enabled_events,omitempty" xml:"enabled_events,omitempty"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// SubmitNewEventsResponseBody is the type of the "Zebrahook" service
// "submitNewEvents" endpoint HTTP response body.
type SubmitNewEventsResponseBody struct {
	Success *bool `form:"success,omitempty" json:"success,omitempty" xml:"success,omitempty"`
}

// RegisterResponseBody is the type of the "Zebrahook" service "register"
// endpoint HTTP response body.
type RegisterResponseBody struct {
	// identifier of the webhook
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// secret to be used by the webhook to verify the events
	Secret *string `form:"secret,omitempty" json:"secret,omitempty" xml:"secret,omitempty"`
}

// UpdateResponseBody is the type of the "Zebrahook" service "update" endpoint
// HTTP response body.
type UpdateResponseBody struct {
	Success *bool `form:"success,omitempty" json:"success,omitempty" xml:"success,omitempty"`
}

// ListWebhookEndpointResponseBody is the type of the "Zebrahook" service
// "listWebhookEndpoint" endpoint HTTP response body.
type ListWebhookEndpointResponseBody struct {
	Result []*WebhookEndpointWithoutSecretResponseBody `form:"result,omitempty" json:"result,omitempty" xml:"result,omitempty"`
}

// GetWebhookEndpointByIDResponseBody is the type of the "Zebrahook" service
// "getWebhookEndpointById" endpoint HTTP response body.
type GetWebhookEndpointByIDResponseBody struct {
	// when this item was created (unix timestamp seconds)
	CreatedAt *int64 `form:"createdAt,omitempty" json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// when this item was last updated (unix timestamp seconds)
	UpdatedAt *int64 `form:"updatedAt,omitempty" json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	// status of current endpoint, enabled means that the webhook endpoint is
	// eligible for receiving webhook events
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// URL of the webhook that will be called on each `enabled_events`
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events,omitempty" json:"enabled_events,omitempty" xml:"enabled_events,omitempty"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
	// identifier of the webhook
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// secret to be used by the webhook to verify the events
	Secret *string `form:"secret,omitempty" json:"secret,omitempty" xml:"secret,omitempty"`
}

// EventRequestRequestBody is used to define fields on request body types.
type EventRequestRequestBody struct {
	// Event type of the `event_content`
	EventType string `form:"event_type" json:"event_type" xml:"event_type"`
	// event content that will be dispatched (any json object)
	EventContent map[string]interface{} `form:"event_content" json:"event_content" xml:"event_content"`
	// Optional priority for this event, an higher number will make this event
	// delivered before other ones
	Priority *int `form:"priority,omitempty" json:"priority,omitempty" xml:"priority,omitempty"`
}

// WebhookEndpointWithoutSecretResponseBody is used to define fields on
// response body types.
type WebhookEndpointWithoutSecretResponseBody struct {
	// when this item was created (unix timestamp seconds)
	CreatedAt *int64 `form:"createdAt,omitempty" json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// when this item was last updated (unix timestamp seconds)
	UpdatedAt *int64 `form:"updatedAt,omitempty" json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	// status of current endpoint, enabled means that the webhook endpoint is
	// eligible for receiving webhook events
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// URL of the webhook that will be called on each `enabled_events`
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// Enabled events for this webhook URL, regex supported - use `["*"]` to listen
	// to all events
	EnabledEvents []string `form:"enabled_events,omitempty" json:"enabled_events,omitempty" xml:"enabled_events,omitempty"`
	// Optionally pass any custom metadata (key->value)
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
	// identifier of the webhook
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// NewSubmitNewEventsRequestBody builds the HTTP request body from the payload
// of the "submitNewEvents" endpoint of the "Zebrahook" service.
func NewSubmitNewEventsRequestBody(p *zebrahook.SubmitNewEventsPayload) *SubmitNewEventsRequestBody {
	body := &SubmitNewEventsRequestBody{}
	if p.Events != nil {
		body.Events = make([]*EventRequestRequestBody, len(p.Events))
		for i, val := range p.Events {
			body.Events[i] = marshalZebrahookEventRequestToEventRequestRequestBody(val)
		}
	}
	return body
}

// NewRegisterRequestBody builds the HTTP request body from the payload of the
// "register" endpoint of the "Zebrahook" service.
func NewRegisterRequestBody(p *zebrahook.RegisterPayload) *RegisterRequestBody {
	body := &RegisterRequestBody{
		URL: p.URL,
	}
	if p.EnabledEvents != nil {
		body.EnabledEvents = make([]string, len(p.EnabledEvents))
		for i, val := range p.EnabledEvents {
			body.EnabledEvents[i] = val
		}
	}
	if p.Metadata != nil {
		body.Metadata = make(map[string]string, len(p.Metadata))
		for key, val := range p.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewUpdateRequestBody builds the HTTP request body from the payload of the
// "update" endpoint of the "Zebrahook" service.
func NewUpdateRequestBody(p *zebrahook.UpdatePayload) *UpdateRequestBody {
	body := &UpdateRequestBody{
		URL:      p.URL,
		Disabled: p.Disabled,
	}
	if p.EnabledEvents != nil {
		body.EnabledEvents = make([]string, len(p.EnabledEvents))
		for i, val := range p.EnabledEvents {
			body.EnabledEvents[i] = val
		}
	}
	if p.Metadata != nil {
		body.Metadata = make(map[string]string, len(p.Metadata))
		for key, val := range p.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewSubmitNewEventsResultOK builds a "Zebrahook" service "submitNewEvents"
// endpoint result from a HTTP "OK" response.
func NewSubmitNewEventsResultOK(body *SubmitNewEventsResponseBody) *zebrahook.SubmitNewEventsResult {
	v := &zebrahook.SubmitNewEventsResult{
		Success: body.Success,
	}

	return v
}

// NewRegisterWebhookIDAndSecretOK builds a "Zebrahook" service "register"
// endpoint result from a HTTP "OK" response.
func NewRegisterWebhookIDAndSecretOK(body *RegisterResponseBody) *zebrahook.WebhookIDAndSecret {
	v := &zebrahook.WebhookIDAndSecret{
		ID:     *body.ID,
		Secret: *body.Secret,
	}

	return v
}

// NewUpdateResultOK builds a "Zebrahook" service "update" endpoint result from
// a HTTP "OK" response.
func NewUpdateResultOK(body *UpdateResponseBody) *zebrahook.UpdateResult {
	v := &zebrahook.UpdateResult{
		Success: body.Success,
	}

	return v
}

// NewListWebhookEndpointResultOK builds a "Zebrahook" service
// "listWebhookEndpoint" endpoint result from a HTTP "OK" response.
func NewListWebhookEndpointResultOK(body *ListWebhookEndpointResponseBody) *zebrahook.ListWebhookEndpointResult {
	v := &zebrahook.ListWebhookEndpointResult{}
	v.Result = make([]*zebrahook.WebhookEndpointWithoutSecret, len(body.Result))
	for i, val := range body.Result {
		v.Result[i] = unmarshalWebhookEndpointWithoutSecretResponseBodyToZebrahookWebhookEndpointWithoutSecret(val)
	}

	return v
}

// NewGetWebhookEndpointByIDWebhookEndpointOK builds a "Zebrahook" service
// "getWebhookEndpointById" endpoint result from a HTTP "OK" response.
func NewGetWebhookEndpointByIDWebhookEndpointOK(body *GetWebhookEndpointByIDResponseBody) *zebrahook.WebhookEndpoint {
	v := &zebrahook.WebhookEndpoint{
		CreatedAt: *body.CreatedAt,
		UpdatedAt: *body.UpdatedAt,
		Status:    body.Status,
		URL:       *body.URL,
		ID:        *body.ID,
		Secret:    *body.Secret,
	}
	v.EnabledEvents = make([]string, len(body.EnabledEvents))
	for i, val := range body.EnabledEvents {
		v.EnabledEvents[i] = val
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]string, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// ValidateRegisterResponseBody runs the validations defined on
// RegisterResponseBody
func ValidateRegisterResponseBody(body *RegisterResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Secret == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("secret", "body"))
	}
	return
}

// ValidateListWebhookEndpointResponseBody runs the validations defined on
// ListWebhookEndpointResponseBody
func ValidateListWebhookEndpointResponseBody(body *ListWebhookEndpointResponseBody) (err error) {
	if body.Result == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("result", "body"))
	}
	for _, e := range body.Result {
		if e != nil {
			if err2 := ValidateWebhookEndpointWithoutSecretResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateGetWebhookEndpointByIDResponseBody runs the validations defined on
// GetWebhookEndpointByIdResponseBody
func ValidateGetWebhookEndpointByIDResponseBody(body *GetWebhookEndpointByIDResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Secret == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("secret", "body"))
	}
	if body.URL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("url", "body"))
	}
	if body.EnabledEvents == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("enabled_events", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("createdAt", "body"))
	}
	if body.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updatedAt", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "enabled" || *body.Status == "disabled") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"enabled", "disabled"}))
		}
	}
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
	}
	if len(body.EnabledEvents) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.enabled_events", body.EnabledEvents, len(body.EnabledEvents), 1, true))
	}
	for k, v := range body.Metadata {
		if utf8.RuneCountInString(k) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata.key", k, utf8.RuneCountInString(k), 1, true))
		}
		if utf8.RuneCountInString(v) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata[key]", v, utf8.RuneCountInString(v), 1, true))
		}
	}
	return
}

// ValidateEventRequestRequestBody runs the validations defined on
// EventRequestRequestBody
func ValidateEventRequestRequestBody(body *EventRequestRequestBody) (err error) {
	if body.EventContent == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event_content", "body"))
	}
	return
}

// ValidateWebhookEndpointWithoutSecretResponseBody runs the validations
// defined on WebhookEndpointWithoutSecretResponseBody
func ValidateWebhookEndpointWithoutSecretResponseBody(body *WebhookEndpointWithoutSecretResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.URL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("url", "body"))
	}
	if body.EnabledEvents == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("enabled_events", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("createdAt", "body"))
	}
	if body.UpdatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("updatedAt", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "enabled" || *body.Status == "disabled") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"enabled", "disabled"}))
		}
	}
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
	}
	if len(body.EnabledEvents) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.enabled_events", body.EnabledEvents, len(body.EnabledEvents), 1, true))
	}
	for k, v := range body.Metadata {
		if utf8.RuneCountInString(k) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata.key", k, utf8.RuneCountInString(k), 1, true))
		}
		if utf8.RuneCountInString(v) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata[key]", v, utf8.RuneCountInString(v), 1, true))
		}
	}
	return
}
