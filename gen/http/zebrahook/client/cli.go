// Code generated by goa v3.7.2, DO NOT EDIT.
//
// Zebrahook HTTP client CLI support package
//
// Command:
// $ goa gen zebrahook/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"
	zebrahook "zebrahook/gen/zebrahook"

	goa "goa.design/goa/v3/pkg"
)

// BuildSubmitNewEventsPayload builds the payload for the Zebrahook
// submitNewEvents endpoint from CLI flags.
func BuildSubmitNewEventsPayload(zebrahookSubmitNewEventsBody string, zebrahookSubmitNewEventsToken string) (*zebrahook.SubmitNewEventsPayload, error) {
	var err error
	var body SubmitNewEventsRequestBody
	{
		err = json.Unmarshal([]byte(zebrahookSubmitNewEventsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"events\": [\n         {\n            \"event_data\": {\n               \"amount\": 8000,\n               \"currency\": \"eur\",\n               \"id\": 372853,\n               \"payment_method_details\": {\n                  \"card\": {\n                     \"brand\": \"visa\"\n                  }\n               }\n            },\n            \"event_type\": \"merchant-93842.charge.succeeded\"\n         },\n         {\n            \"event_data\": {\n               \"customer\": {\n                  \"address\": \"Lorem Ipsum 33\",\n                  \"country\": \"NL\"\n               },\n               \"order_id\": 12643,\n               \"sku\": \"9001-2\",\n               \"type\": \"A01\"\n            },\n            \"event_type\": \"merchant-93842.order.shipped\"\n         }\n      ]\n   }'")
		}
		if body.Events == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("events", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var token string
	{
		token = zebrahookSubmitNewEventsToken
	}
	v := &zebrahook.SubmitNewEventsPayload{}
	if body.Events != nil {
		v.Events = make([]*zebrahook.EventRequest, len(body.Events))
		for i, val := range body.Events {
			v.Events[i] = marshalEventRequestRequestBodyToZebrahookEventRequest(val)
		}
	}
	v.Token = token

	return v, nil
}

// BuildRegisterPayload builds the payload for the Zebrahook register endpoint
// from CLI flags.
func BuildRegisterPayload(zebrahookRegisterBody string, zebrahookRegisterToken string) (*zebrahook.RegisterPayload, error) {
	var err error
	var body RegisterRequestBody
	{
		err = json.Unmarshal([]byte(zebrahookRegisterBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"enabled_events\": [\n         \"merchant-93842.order.*\",\n         \"my.custom.event\"\n      ],\n      \"metadata\": {\n         \"anyKeyHere\": \"any value here\"\n      },\n      \"url\": \"https://example.com/notifications\"\n   }'")
		}
		if body.EnabledEvents == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("enabled_events", "body"))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", body.URL, goa.FormatURI))

		if len(body.EnabledEvents) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.enabled_events", body.EnabledEvents, len(body.EnabledEvents), 1, true))
		}
		for k, v := range body.Metadata {
			if utf8.RuneCountInString(k) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata.key", k, utf8.RuneCountInString(k), 1, true))
			}
			if utf8.RuneCountInString(v) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata[key]", v, utf8.RuneCountInString(v), 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var token string
	{
		token = zebrahookRegisterToken
	}
	v := &zebrahook.RegisterPayload{
		URL: body.URL,
	}
	if body.EnabledEvents != nil {
		v.EnabledEvents = make([]string, len(body.EnabledEvents))
		for i, val := range body.EnabledEvents {
			v.EnabledEvents[i] = val
		}
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]string, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	v.Token = token

	return v, nil
}

// BuildUpdatePayload builds the payload for the Zebrahook update endpoint from
// CLI flags.
func BuildUpdatePayload(zebrahookUpdateBody string, zebrahookUpdateID string, zebrahookUpdateToken string) (*zebrahook.UpdatePayload, error) {
	var err error
	var body UpdateRequestBody
	{
		err = json.Unmarshal([]byte(zebrahookUpdateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"disabled\": true,\n      \"enabled_events\": [\n         \"your.event_name\",\n         \"custom.event.*\"\n      ],\n      \"metadata\": {\n         \"anyKeyHere\": \"any value here\"\n      },\n      \"url\": \"https://example.com/notifications\"\n   }'")
		}
		if body.URL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
		}
		for k, v := range body.Metadata {
			if utf8.RuneCountInString(k) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata.key", k, utf8.RuneCountInString(k), 1, true))
			}
			if utf8.RuneCountInString(v) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.metadata[key]", v, utf8.RuneCountInString(v), 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = zebrahookUpdateID
	}
	var token string
	{
		token = zebrahookUpdateToken
	}
	v := &zebrahook.UpdatePayload{
		URL:      body.URL,
		Disabled: body.Disabled,
	}
	if body.EnabledEvents != nil {
		v.EnabledEvents = make([]string, len(body.EnabledEvents))
		for i, val := range body.EnabledEvents {
			v.EnabledEvents[i] = val
		}
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]string, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	v.ID = id
	v.Token = token

	return v, nil
}

// BuildListWebhookEndpointPayload builds the payload for the Zebrahook
// listWebhookEndpoint endpoint from CLI flags.
func BuildListWebhookEndpointPayload(zebrahookListWebhookEndpointLimit string, zebrahookListWebhookEndpointOffset string, zebrahookListWebhookEndpointCreatedAtGte string, zebrahookListWebhookEndpointUpdatedAtLt string, zebrahookListWebhookEndpointMetadata string, zebrahookListWebhookEndpointToken string) (*zebrahook.ListWebhookEndpointPayload, error) {
	var err error
	var limit int32
	{
		if zebrahookListWebhookEndpointLimit != "" {
			var v int64
			v, err = strconv.ParseInt(zebrahookListWebhookEndpointLimit, 10, 32)
			limit = int32(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT32")
			}
		}
	}
	var offset uint32
	{
		if zebrahookListWebhookEndpointOffset != "" {
			var v uint64
			v, err = strconv.ParseUint(zebrahookListWebhookEndpointOffset, 10, 32)
			offset = uint32(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be UINT32")
			}
		}
	}
	var createdAtGte *uint64
	{
		if zebrahookListWebhookEndpointCreatedAtGte != "" {
			val, err := strconv.ParseUint(zebrahookListWebhookEndpointCreatedAtGte, 10, 64)
			createdAtGte = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for createdAtGte, must be UINT64")
			}
			if createdAtGte != nil {
				if *createdAtGte < 0 {
					err = goa.MergeErrors(err, goa.InvalidRangeError("createdAtGte", *createdAtGte, 0, true))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var updatedAtLt *uint64
	{
		if zebrahookListWebhookEndpointUpdatedAtLt != "" {
			val, err := strconv.ParseUint(zebrahookListWebhookEndpointUpdatedAtLt, 10, 64)
			updatedAtLt = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for updatedAtLt, must be UINT64")
			}
			if updatedAtLt != nil {
				if *updatedAtLt < 0 {
					err = goa.MergeErrors(err, goa.InvalidRangeError("updatedAtLt", *updatedAtLt, 0, true))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var metadata map[string]string
	{
		if zebrahookListWebhookEndpointMetadata != "" {
			err = json.Unmarshal([]byte(zebrahookListWebhookEndpointMetadata), &metadata)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for metadata, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"metadata\": \"valuehere\"\n   }'")
			}
		}
	}
	var token string
	{
		token = zebrahookListWebhookEndpointToken
	}
	v := &zebrahook.ListWebhookEndpointPayload{}
	v.Limit = limit
	v.Offset = offset
	v.CreatedAtGte = createdAtGte
	v.UpdatedAtLt = updatedAtLt
	v.Metadata = metadata
	v.Token = token

	return v, nil
}

// BuildGetWebhookEndpointByIDPayload builds the payload for the Zebrahook
// getWebhookEndpointById endpoint from CLI flags.
func BuildGetWebhookEndpointByIDPayload(zebrahookGetWebhookEndpointByIDID string, zebrahookGetWebhookEndpointByIDToken string) (*zebrahook.GetWebhookEndpointByIDPayload, error) {
	var id string
	{
		id = zebrahookGetWebhookEndpointByIDID
	}
	var token string
	{
		token = zebrahookGetWebhookEndpointByIDToken
	}
	v := &zebrahook.GetWebhookEndpointByIDPayload{}
	v.ID = id
	v.Token = token

	return v, nil
}
